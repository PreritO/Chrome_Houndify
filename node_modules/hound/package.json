{
  "name": "hound",
  "version": "0.2.1",
  "main": "index.js",
  "devDependencies": {
    "babelify": "^6.1.3",
    "browserify-derequire": "^0.9.4",
    "grunt": "~0.4.0",
    "grunt-babel": "^5.0.1",
    "grunt-browserify": "latest",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-concat": "^0.5.1",
    "grunt-contrib-copy": "^0.8.0",
    "grunt-contrib-uglify": "latest",
    "grunt-contrib-watch": "latest",
    "grunt-shell": "^1.1.2",
    "pako": "^0.2.7"
  },
  "dependencies": {
    "crypto": "0.0.3",
    "node-uuid": "^1.4.3",
    "request": "^2.60.0"
  },
  "author": {
    "name": "Asif Amirguliyev",
    "email": "aamirgul@soundhound.com"
  },
  "readme": "# Houndify Web SDK\n\nThe Houndify Web SDK allows you to make voice and text queries to the Houndify API from your browser.\n\n## Features\n\n* Voice search (Chrome, Firefox)\n* Text search (Chrome, Firefox, Safari, IE)\n* Conversation state\n* Voice Activity Detection\n\n## Structure\n\nWeb SDK consists of two parts: an in-browser javascript library and a server-side node module.\n\n**hound-web-sdk.min.js** is the main part and it runs in the browser. It captures audio and text requests, and processes responses from the backend.\n\nBecause of CORS and security issues we also need a backend part that stores client credentials (Houndify Client ID and Client Key) and acts as a proxy for http requests from browser to Hound backend. Server-side part of SDK is a node module **hound** that contains `HoundNode` object with two methods that build express middlewares for authentication/proxy and two more helper methods.\n\n## Set up\n\n### Client Side\n\nClient-side part of Web SDK doesn't have any dependencies right now and consists of a single 725Kb file. You can include it via script tag and work with global `Hound` object.\n\n```html\n<script src=\"/path/to/hound-web-sdk.min.js\"></script>\n<script>\nvar searchObject = new Hound.TextSearch(/* ..args.. */);\n</script>\n```\n\nOr you can *require* `Hound` as a CommonJS module.\n\n```javascript\nvar Hound = require('path/to/hound-web-sdk.min'); //or require('hound').Hound\n\nvar searchObject = new Hound.TextSearch(/* ..args.. */);\n```\n\n### Server Side\n\nServer-side part of SDK is in the a **hound** node module [that also includes client-side `Hound`]. \n\n**The module is not yet published to npm but is packed into hound-VERSION.tgz. You can run `npm install hound-VERSION.tgz` to install it.**\n\n`HoundNode` object in the module has four methods used for authenticating and proxying voice and text search requests.\n\n```javascript\nvar hound = require('hound').HoundNode;\n```\n\n### Example Project\n\n*example* folder contains a project that shows a working setup of SDK. It contains a node *server.js* and *public* folder with frontend. \n\n`npm install` should install both **express** from npm and **hound** from *hound-VERSION.tgz*. \n\nYou'll need to fill in your Houndify Client information in *config.json*. Make sure you also change \"YOUR_CLIENT_ID\" with your actual client id in `requestInfo` in *example/public/index.html* file.\n\nYou will also need ssl certificate and key files for starting https server. **Latest browsers require secure connection for access to microphone.** Add *server.key* and *server.crt* files to the project root.\n\nRun `node server.js` in the project folder and go to the url shown in the output of the running node server. Default one is https://localhost:3446.\n\n## Using SDK\n\n`Hound` object contains two constructors for search objects, `TextSearch` and `VoiceSearch`, and a constructor for `Conversation` object that is used to store conversation state.\n\n```javascript\nvar searchObject = new TextSearch({\n  proxy: {\n    route: \"/textSearchProxy\"\n  },\n  onResponse: function(response, info) {\n    /* handle response here */\n  }\n});\n\nsearchObject.search(\n  \"What is the weather like in Toronto?\",  // query\n  {                                        // request info\n    UserID: \"as124faa12\",  \n    City: \"Toronto\", \n    Country: \"Canada\"\n  }\n);\n```\n\n### Voice Search\n\nIn order to use Voice Search you'll need an authentication endpoint on your server. **hound** module contains `HoundNode` object with *createVoiceAuthHandler()* method that takes Houndify ClientID and ClientKey and creates an express middleware for handling voice search authentication.\n\n**Note!** For voice search to work the frontend should be served through secure connection. See example project for https node server setup.\n\n```javascript\nvar hound = require('hound').HoundNode;\n\n/* create an express app*/\n\n//authenticates voice search requests\napp.get('/voiceSearchAuth', hound.createVoiceAuthHandler({ \n  clientId:  \"YOUR_CLIENT_ID\", \n  clientKey: \"YOUR_CLIENT_KEY\"\n}));\n```\n\nIn the browser you need to create a **VoiceSearch** object that expects authentication endpoint, `Conversation` object and several event handlers passed in the options:\n\n```javascript\nvar voiceSearch = new Hound.VoiceSearch({\n\n  //You need to create an endpoint on your server\n  //for handling the authentication.\n  //See SDK's server-side method HoundNode.createVoiceAuthHandler().\n  authenticationURI: \"/voiceSearchAuth\",\n\n  //Create one global Conversation object \n  //to share the conversation state between Text and Voice Search objects\n  conversation: new Hound.Conversation(),\n\n  //Enable Voice Activity Detection\n  //Default: true\n  enableVAD: true,\n\n  //Listeners\n\n  //Fires every time backend sends a speech-to-text \n  //transcript of a voice query\n  //See https://houndify.com/reference/HoundPartialTranscript\n  onTranscriptionUpdate: function(transcript) {},\n\n  //Fires after server responds with Response JSON\n  //Info object contains useful information about the completed request\n  //See https://houndify.com/reference/HoundServer\n  onResponse: function(response, info) {},\n\n  //Fires after abort() method is called on search object\n  onAbort: function(info) {},\n\n  //Fires if error occurs during the request\n  onError: function(err, info) {},\n\n  //Fires when start() metods is called on search object\n  onRecordingStarted: function() {},\n\n  //Fires when recording ends either after stop(), abort() or\n  //when server detects the end of query and responds \n  //(VAD: https://houndify.com/docs#voice-activity-detection)\n  onRecordingStopped: function(recording) {},\n\n  //Fires every time new audio frame of recording is captured\n  onAudioFrame: function(frame) {}\n});\n```\n\nCreated `VoiceSearch` object will have five methods *start()*, *stop()*, *abort()*, *upload()* and *destroy()*.\n\n```javascript\n//see https://houndify.com/reference/RequestInfo\nvar requestInfo = { \n  UserID: \"as124faa12\", \n  City: \"Toronto\", \n  Country: \"Canada\"\n};\n\n//starts streaming of voice search requests to Hound backend\nvoiceSearch.start(requestInfo);\n\n/* ... */\n\n//stops streaming voice search requests, expects the final response from backend\nvoiceSearch.stop();\n\n/* ... */\n\n//aborts voice search request, does not expect final response from backend\nvoiceSearch.abort();\n\n/* ... */\n\n// pass arrayBuffer from WAV file \n// to voiceSearch.upload() along with requestInfo \n// to get voice search results for pre-recorded audio.\n// The audio should have sampling rate of at least 16KHz.\n// NOTE: \"fileInput\" element is some <input type=\"file\" id=\"fileInput\" onchange=\"onFileUpload()\" /> in your html\nfunction onFileUpload() {\n  var fileElt = document.getElementById(\"fileInput\");\n  var file = fileElt.files[0];\n  if (!file) return;\n\n  var reader = new FileReader();\n  reader.onload = function(){\n    var arrayBuffer = reader.result;\n    voiceSearch.upload(arrayBuffer, requestInfo);\n  };\n\n  reader.readAsArrayBuffer(file);\n}\n\n/* ... */\n\n// destroy the existing voiceSearch object if you need to create a new one.\n// browsers have limits on number of AudioContext objects in a single session\nvoiceSearch.destroy()\n```\n\n### Text Search\n\nSetting up Text Search is similar to Voice Search.\n\nIn order to use Text Search you'll need an authentication/proxy endpoint on your server. `HoundNode` object contains *createTextProxyHandler()* method that takes Houndify ClientID and ClientKey for handling text search requests.\n\n```javascript\nvar hound = require('hound').HoundNode;\n\n/* create an express app*/\n\n// Send the request to http text endpoint with authentication headers\napp.get('/textSearchProxy', hound.createTextProxyHandler({ \n  clientId:  \"YOUR_CLIENT_ID\", \n  clientKey: \"YOUR_CLIENT_KEY\"\n}));\n```\n\nIn the browser you need to create a `TextSearch` object that expects proxy endpoint details, `Conversation` object and two event handlers passed in the options:\n\n```javascript\nvar textSearch = new Hound.TextSearch({\n\n  //You need to create an endpoint on your server\n  //for handling the authentication and proxying \n  //text search http requests to Hound backend\n  //See SDK's server-side method HoundNode.createTextProxyHandler().\n  proxy: {\n    route: \"/textSearchProxy\",\n    // method: \"GET\",\n    // headers: []\n    // ... More proxy options will be added as needed\n  },\n\n  //Create one global Conversation object \n  //to share the conversation state between Text and Voice Search objects\n  conversation: new Hound.Conversation(),\n\n  //Listeners\n\n  //Fires after server responds with Response JSON\n  //Info object contains useful information about the completed request\n  //See https://houndify.com/reference/HoundServer\n  onResponse: function(response, info) {},\n\n  //Fires if error occurs during the request\n  onError: function(err, info) {}\n});\n```\n\nCreated `TextSearch` object will have *search()* method that accepts a query string and request info object.\n\n```javascript\n//see https://houndify.com/reference/RequestInfo\nvar requestInfo = { \n  UserID: \"as124faa12\", \n  City: \"Toronto\", \n  Country: \"Canada\"\n};\n\nvar query = \"What is the weather like in Toronto?\";\n\n//starts streaming of voice search requests to Hound backend\ntextSearch.search(query, requestInfo);\n```\n\n### Conversation State\n\nHoundified domains can use context to enable a conversational user interaction. For example, users can say \"show me coffee shops near me\", \"which ones have wifi?\", \"sort by rating\", \"navigate to the first one\". In order to store and share conversation between text and voice queries you can create a `Conversation` object and pass it to search objects.\n\n```javascript\nvar myConversation = new Hound.Conversation();\n\nvar voiceSearch = new VoiceSearch({\n  conversation: myConversation,\n\n  /* other options... */\n});\n\nvar textSearch = new TextSearch({\n  conversation: myConversation,\n\n  /* other options... */\n});\n```\n\nYou may call *clear()* method on `Conversation` object in order to forget the conversation.\n\n\n```javascript\nvar myConversation = new Hound.Conversation();\n\n/* ... */\n\nmyConversation.clear();\n```\n\n## Extra\n\n### Voice Search without Server-side module\n\nYou can use Voice Search in the browser without setting up node server. You can pass in the authentication information directly to `VoiceSearch` object and use a https server of your choice without server-side **hound** module. \n\n**Important!** Your client key should be private and it is not recommended to expose it in the browser in production. Use Voice Search without authentication through server side only for testing the platform or internal applications.\n\n```javascript\nvar voiceSearch = new Hound.VoiceSearch({\n  // Provide client information here\n  // to skip the authentication on server side\n  client: {\n    clientId: \"YOUR_CLIENT_ID\",\n    clientKey: \"YOUR_CLIENT_KEY\"\n  },\n\n  /* other options... */\n});\n```\n\n### Other HoundNode Methods\n\nServer-side node module **hound** has four methods, two of which are mentioned above (creating express middleware for authentication and proxying requests). There are two more helper methods in the `HoundNode` object. These methods are helpers for procedures described in [Docs#Authentication](https://www.houndify.com/docs#authentication):\n\n* *generateAuthHeaders(clientId, clientKey, userId, requestId, timestamp)* generates the headers for HTTP Text and Voice Requests. clientId and clientKey are required, while other headers are optional. **Note:** all fields here should be the same as in Request Info JSON;\n* *signToken(token, clientKey)* generates signed token for Websocket Voice Requests. \n\n\n\n",
  "readmeFilename": "README.md",
  "description": "The Houndify Web SDK allows you to make voice and text queries to the Houndify API from your browser.",
  "_id": "hound@0.2.1",
  "_shasum": "11521a460084afc0e6a83cd62cac71c6075886ce",
  "_resolved": "file:hound-0.2.1.tgz",
  "_from": "hound-0.2.1.tgz"
}
